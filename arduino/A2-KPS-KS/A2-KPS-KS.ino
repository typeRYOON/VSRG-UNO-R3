/* A2-KPS-KS.ino */
/* ---------------------------------------------------------------------------------------
 >> Assignment details and provided code are created and owned by Patrick Troy.
 >> University of Illinois at Chicago - CS 362, Spring 2024
 >> --------------------------------------------------------------------------------------
 >> File    :: A2-KPS-KS.ino :: VSRG-UNO-R3: Arduino 2, Nokia 5110 LCD + 16x2 LCD
 >> Course  :: CS 362 (47019), SP24
 >> Author  :: Ryan Magdaleno
 >> UIN/nID :: 668523658 (rmagd2)
 >> System  :: Windows 10 w/ Mingw-w64
 - -                               - -
 >> File overview ::
 >> This file is the implementation for the VSRG-UNO-R3 Arduino 2 keystrokes + KPS stat
 >> displays. This program can receive a signal from Arduino 1 that turns the displays
 >> off. This program is meant to be run with the VSRG-UNO-R3 GUI. Link below
 - -              >> https://github.com/typeRYOON/VSRG-UNO-R3 <<                       - -
 >> Please read the instructions on the github page to understand how to run this
 >> Arduino. Hardware required is listed in the repository README/documentation files.
--------------------------------------------------------------------------------------- */
// Preprocessor directives ::
#include <Adafruit_PCD8544.h>
#include <LiquidCrystal.h>
#include <Adafruit_GFX.h>
#include <Wire.h>
#include <SPI.h>

// Global variables :: - -                                                             - -
const uint8_t VSRG[] PROGMEM = { // 'VSRG' bitmap :: 10x48px
  0x0c, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x0c, 0x00, 0x0c, 0x00,
  0x0c, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x77, 0x00, 0x61, 0x80, 0x61, 0xc0,
  0x61, 0xc0, 0x01, 0xc0, 0x01, 0x80, 0x27, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x71, 0x80,
  0x31, 0x80, 0x19, 0x80, 0x1d, 0x80, 0x39, 0x80, 0x31, 0x80, 0x31, 0x80, 0x3f, 0x80,
  0x07, 0x00, 0x0f, 0x00, 0x3f, 0x80, 0x30, 0x00, 0x30, 0x00, 0x3c, 0x00, 0x0f, 0x00,
  0x03, 0x80, 0x03, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x1e, 0x00, 0x1e, 0x00,
  0x33, 0x00, 0x33, 0x00, 0x33, 0x80, 0x61, 0x80, 0x61, 0x80, 0xc0, 0xc0
};

const uint8_t Kurisu[] PROGMEM = { // 'Kurisu' bitmap :: 48x70px
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 
  0x80, 0x00, 0x00, 0x00, 0x02, 0xe7, 0x80, 0x09, 0xe0, 0x00, 0x03, 0xf7, 0x80, 0x0d, 
  0x08, 0x00, 0x07, 0x7d, 0xc0, 0x0b, 0xc4, 0x00, 0x03, 0x7e, 0xc0, 0x0a, 0x10, 0x00, 
  0x03, 0x3e, 0xc0, 0x00, 0x89, 0x08, 0x03, 0x1f, 0xc0, 0x00, 0xc0, 0x08, 0x03, 0x2f, 
  0xe0, 0x01, 0x04, 0x18, 0x01, 0x37, 0xf0, 0x03, 0x10, 0x88, 0x01, 0x77, 0xf8, 0x02, 
  0x02, 0x00, 0x00, 0xc7, 0xfc, 0x30, 0x0a, 0x20, 0x00, 0x23, 0xfc, 0x80, 0x00, 0xc0, 
  0x00, 0x23, 0xef, 0x00, 0x04, 0x40, 0x00, 0x23, 0xfe, 0x72, 0x05, 0x80, 0x00, 0x03, 
  0xd7, 0xe8, 0x04, 0x80, 0x00, 0x13, 0xdb, 0x30, 0x05, 0x00, 0x00, 0x0f, 0xdb, 0x21, 
  0x05, 0x00, 0x00, 0x0f, 0xef, 0x00, 0x07, 0x00, 0x00, 0x0f, 0xff, 0x00, 0x07, 0x00, 
  0x00, 0x0f, 0xff, 0x01, 0x0f, 0x00, 0x00, 0x0f, 0xfe, 0x05, 0x1f, 0x00, 0x00, 0x0f, 
  0xfe, 0x1a, 0x3f, 0x00, 0x00, 0x0f, 0xdc, 0x7c, 0x7f, 0x00, 0x00, 0x0f, 0x82, 0xb8, 
  0xff, 0x00, 0x00, 0x1f, 0x00, 0x39, 0xff, 0x00, 0x00, 0x1e, 0x00, 0x11, 0xff, 0x00, 
  0x00, 0x3c, 0x40, 0x13, 0xff, 0x00, 0x00, 0x38, 0x00, 0x17, 0x7f, 0x00, 0x00, 0x38, 
  0x00, 0x1f, 0xbf, 0x80, 0x00, 0x70, 0x00, 0x0f, 0xbf, 0x80, 0x00, 0x70, 0x00, 0x0f, 
  0xff, 0x80, 0x00, 0x70, 0x00, 0x5f, 0xff, 0x80, 0x00, 0x71, 0x01, 0xbf, 0xff, 0x80, 
  0x00, 0x71, 0x71, 0xff, 0xff, 0x80, 0x00, 0x77, 0x37, 0xff, 0xff, 0xc0, 0x00, 0x77, 
  0xfd, 0xef, 0xff, 0xc0, 0x00, 0x7e, 0xfe, 0x2f, 0xff, 0xc0, 0x00, 0x7d, 0xff, 0x6f, 
  0xff, 0xc0, 0x00, 0x79, 0xff, 0x7f, 0xff, 0xc0, 0x00, 0x79, 0xff, 0xff, 0xff, 0xc0, 
  0x00, 0x7f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x7b, 0xff, 0xff, 0xdf, 0x80, 0x00, 0x7f, 
  0xc7, 0xe0, 0x4f, 0x80, 0x00, 0x1e, 0x07, 0xfc, 0x4f, 0x80, 0x00, 0x32, 0x5f, 0xff, 
  0xcf, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0x00, 0x00, 0x13, 0xff, 0xff, 0xff, 0x00, 
  0x00, 0x07, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x07, 
  0xff, 0xff, 0xf8, 0x00, 0x00, 0x03, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x01, 0xff, 0xff, 
  0xe0, 0x00, 0x00, 0x00, 0x7f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 16x2 display variables :: - -                                                       - -
LiquidCrystal LCD( 2, 3, 4, 5, 6, 7 );
char s_KPS[9], s_KS[16]; // Top/Bottom row buffers.

// Nokia 5110 display variables :: - -                                                 - -
Adafruit_PCD8544 Nokia = Adafruit_PCD8544( 8, 9, 10, 11, 12 );
const uint8_t WIDTH = 14, HEIGHT = 48;
uint8_t KS_Bits[WIDTH][HEIGHT] = { 0 }, drawIterations = 0;
int32_t rawKPS_KS, KS;

// Program flow variables :: - -                                                       - -
uint32_t now, prev = millis();
bool draw = true, off = false;

// Set up external devices + communication pipelines :: - -                            - -
void setup()
{ // Set up the 16x2 LCD :: - -                                                        - -
  LCD.begin( 16, 2 );
  LCD.println( "KPS :: 0        " );
  LCD.print  ( "                " );

  // Set up the Nokia 5110 LCD :: - -                                                  - -
  Nokia.begin();
  Nokia.setContrast( 50 );
  Nokia.clearDisplay();
  Nokia.drawBitmap( 10, -15, Kurisu, 48, 70, BLACK );
  Nokia.drawBitmap( 9 ,  0 , VSRG  , 10, 48, BLACK );
  Nokia.display();

  // Set up the I2C wire connection :: - -                                             - -
  Wire.begin( 5 );
  Wire.onReceive( buttonPressed );

  // Set up the 9600 baud rate serial USB connection :: - -                            - -
  Serial.begin( 9600 );
}

// Given a keystroke binary mapping, update the KS bitmap :: - -                       - -
void updateBitmap( const int32_t KS )
{ // Shift values up :: - -                                                            - -
  for ( uint8_t x = 0; x < WIDTH; ++x ) {
    for ( int8_t y = HEIGHT - 1; y >= 0; y -= 2 )
    {
      KS_Bits[x][y - 1] = KS_Bits[x][y - 2];
      KS_Bits[x][y]     = KS_Bits[x][y - 1];
    }
  }
  // Add new 14x2px row to bottom of KS bitmap :: - -                                  - -
  for ( uint16_t i = 2, x = 0; i <= 128; i <<= 1 )
  {
    KS_Bits[x]  [0] = KS & i; //  Note ::
    KS_Bits[x++][1] = KS & i; //  Each column is 2 pixels wide.
    KS_Bits[x]  [0] = KS & i; //  So we must increment x forward
    KS_Bits[x++][1] = KS & i; //  2 pixels for each loop iteration.
  }
}

// Draw current KS_Bits bitmap onto Nokia display :: - -                               - -
void drawBitmap( const bool print ) // 'print' turns drawing/clearing on/off.
{
  for ( uint8_t x = 0; x < WIDTH; ++x ) {
    for ( uint8_t y = 0; y < HEIGHT; ++y )
    {
      if ( print && KS_Bits[x][y] ) { Nokia.drawPixel( x + 60, y, BLACK ); }
      else                          { Nokia.drawPixel( x + 60, y, WHITE ); }
    }
  }
  Nokia.display();
}

// Given a raw binary mapping, retrieve the KPS and update the 16x2 display :: - -     - -
void print16_2( const int32_t KPS )
{ // First 10 bits are for KS, so get latter 22 bits:
  sprintf( s_KPS, "%d       ", ( KPS & 0xFFFFC00 ) >> 10 );

  // Get KS mapping, bits 2-8:
  for ( int i = 2, j = 0; i <= 128; i <<= 1 ) {
    s_KS[j++] = i & KPS ? '\xDB' : ' ';
  }
  // Update 16x2 display:
  LCD.setCursor( 7, 0 );
  LCD.print( s_KPS );
  LCD.setCursor( 0, 1 );
  LCD.print( s_KS );
}

// Arduino 1 will send a number via I2C, changes display states :: - -                 - -
void buttonPressed( int32_t _ )
{
  while ( Wire.available() ) {
    int32_t i = Wire.read();
    if ( i ) 
    { // Displays are now set to ON state:
      LCD.setCursor( 0, 0 );
      LCD.println( "KPS :: 0        " );
      LCD.print  ( "                " );
      off = false;
    } else 
    { // Displays are now set to OFF state:
      drawBitmap( false );
      LCD.clear();
      off = true;
    }
  }
}

// Main Arduino loop, every 20ms there should be a serial value :: - -                 - -
void loop()
{
  if ( Serial.available() )
  { // Example :: "#12345678#"
    String rawSerial = Serial.readStringUntil( '#' );
    if ( rawSerial.length() > 0 ) {
      rawSerial.trim();
      rawKPS_KS = rawSerial.toInt();

      // 0xFE = 0b11111110, 7 relevant key columns:
      updateBitmap( rawKPS_KS & 0xFE );

      // Displays are in off state, do not draw to them:
      if ( off ) { return; }

      // Only update Nokia LCD every 60ms, performance fix:
      if ( drawIterations++ == 3 ) {
        drawIterations = 0;
        drawBitmap( true );
      }
      print16_2( rawKPS_KS );
      prev = millis();
      draw = true;
    }
  }
  // Clear displays if USB serial becomes inactive :: - -                              - -
  now = millis();
  if ( draw && now - prev >= 500 )
  {
    LCD.clear();
    LCD.println( "KPS :: 0        " );
    LCD.print  ( "                " );
    drawBitmap( false );
    draw = false;
    prev = now;
  }
} // :: - -                                                                            - -
